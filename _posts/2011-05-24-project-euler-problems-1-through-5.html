---
layout: post
title: Project Euler, Problems 1 Through 5
textdate: Tuesday, May 24, 2011
categories: [project euler, cplusplus, code sample]
---
<p>Since I'm currently looking for a job I've started going through the
exercises from <a href="http://projecteuler.net/">Project Euler</a>. The idea
is to get some practice in the sort of programming problems that are given in
interviews, refresh my C++ knowledge which has gotten rather rusty, and provide
some code samples for potential employers.

<h3>Problem 1: Summing Multiples of 3 or 5</h3>

<blockquote>
<p>If we list all the natural numbers below 10 that are multiples of 3 or 5, we get
3, 5, 6 and 9. The sum of these multiples is 23.

<p>Find the sum of all the multiples of 3 or 5 below 1000.
</blockquote>


<p>This is a rather trivial problem, so I'll skip any discussion of it and just
present my solution.

<pre class="code">
#include &lt;iostream&gt;

int main()
{
    int sum = 0;

    for (int i=3; i&lt;1000; i++) {
        if (i % 3 == 0 || i % 5 == 0) {
            sum += i;
        }
    }

    std::cout &lt;&lt; sum &lt;&lt; std::endl;

    return 0;
}
</pre>

<h3>Problem 2: Summing Even Fibonacci Numbers</h3>

<blockquote>
<p>Each new term in the Fibonacci sequence is generated by adding the previous two
terms. By starting with 1 and 2, the first 10 terms will be:

<p>1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

<p>By considering the terms in the Fibonacci sequence whose values do not exceed
four million, find the sum of the even-valued terms.
</blockquote>

<p>Like the previous one, this is too trivial for any discussion.

<pre class="code">
#include &lt;iostream&gt;

int main()
{
    long sum = 0;
    long a = 1, b = 2;

    while (b &lt; 4000000) {
        if (b % 2 == 0) {
            sum += b;
        }

        long temp = b + a;
        a = b;
        b = temp;
    }

    std::cout &lt;&lt; sum &lt;&lt; std::endl;

    return 0;
}
</pre>

<h3>Problem 3: Largest Prime Factor</h3>

<blockquote>
<p>The prime factors of 13195 are 5, 7, 13 and 29.

<p>What is the largest prime factor of the number 600851475143 ?
</blockquote>

<p>There are two moderately interesting things about this problem. The first is
that it involves primality testing, which is slightly tricky. Naive solutions
are quite easy, but more efficient solutions are much more tricky. I've stuck to
the naive approach, since the numbers aren't sufficiently large to justify
writing a complicated algorithm.

<p>The second moderately interesting point is that this problem uses numbers
outside the guaranteed range of a C++ long integer. Because of this, I used the
<tt>long long</tt> type, which isn't standard in C++ yet (though it is widely
supported).

<pre class="code">
#include &lt;iostream&gt;

// long long is not strict C++, unfortunately.

bool is_prime(long long val)
{
    if (val &lt; 2) return false;
    if (val == 2) return true;
    if (val % 2 == 0) return false;

    long long i = 3;

    while (i * i &lt;= val) {
        if (val % i == 0) {
            return false;
        }

        i += 2;
    }

    return true;
}

int main() {
    long long val = 600851475143LL;
    long long i = 2;
    long long largest = 0;

    while (i * i &lt;= val) {
        if (is_prime(i) &amp;&amp; val % i == 0) {
            largest = i;
        }

        i++;
    }

    std::cout &lt;&lt; largest &lt;&lt; std::endl;

    return 0;
}
</pre>

<h3>Problem 4: Largest Palindromic Number</h3>

<blockquote>
<p>A palindromic number reads the same both ways. The largest palindrome made from
the product of two 2-digit numbers is 9009 = 91 Ã— 99.

<p>Find the largest palindrome made from the product of two 3-digit numbers.
</blockquote>

<p>This was the first problem that I got wrong initially. The mistake I made was
to iterate over the numbers from largest to smallest, and take the first
palindrome product I found. This isn't actually the largest, however. It is
simply the result that happens to have the largest value for one of the two
factors. That is, the result I ended up with was <tt>995 * 583 = 580085</tt>,
while the actual answer is <tt>993 * 913 = 906609</tt>. I think this is a
somewhat understandable mistake, but certainly a type of error to watch out for.

<pre class="code">
#include &lt;iostream&gt;
#include &lt;sstream&gt;

bool is_palindrome(long val)
{
    std::ostringstream sout;
    sout &lt;&lt; val;

    std::string text(sout.str());
    std::string reversed(text.rbegin(), text.rend());

    return text == reversed;
}

int main()
{
    long max = 0;

    for (int i=99; i&lt;1000; i++) {
        for (int j=i; j&lt;1000; j++) {
            int val = i*j;
            if (is_palindrome(val) &amp;&amp; val &gt; max) {
                max = val;
            }
        }
    }

    std::cout &lt;&lt; max &lt;&lt; std::endl;

    return 0;
}
</pre>

<h3>Problem 5: Smallest Evenly Divisible Number</h3>

<blockquote>
<p>2520 is the smallest number that can be divided by each of the numbers from 1 to
10 without any remainder.

<p>What is the smallest positive number that is evenly divisible by all of the
numbers from 1 to 20?
</blockquote>

<p>There's not much to say about this one. The simple optimization of adding 20
on each iteration didn't occur to me immediately, like it probably should have.

<pre class="code">
#include &lt;iostream&gt;

bool is_divisible(long val)
{
    for (int i=2; i&lt;=20; i++) {
        if (val % i != 0) return false;
    }

    return true;
}

int main()
{
    for (long i=20; ; i+=20) {
        if (is_divisible(i)) {
            std::cout &lt;&lt; i &lt;&lt; std::endl;
            break;
        }
    }

    return 0;
}
</pre>
